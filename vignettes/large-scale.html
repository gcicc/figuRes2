<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Prerequisistes</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Mass figure production workflow demo}</p>

<h1>Prerequisistes</h1>

<h2>Recommended directory structure</h2>

<p>The default.settings function places text objects with default paths to some of these locations.</p>

<ul>
<li>Create a parent directory to associated with your project.</li>
<li>Create subfolders associated with a reporting effort

<ul>
<li> With the reporting effort create the following subfolders:</li>
<li>code: a directory to hold all r driver files</li>
<li>dddata: a directory to hold all .csv files</li>
<li>output: a directory to hold outgoing figure files</li>
<li>log: a directory to hold log files
etc.</li>
</ul></li>
</ul>

<h2>Driver files</h2>

<p>The purpose of these files is single fold: Produce a figure. Recall a figure is considered to be a collection of graphics/tables assembled on a page and annotated with headers/footers/titles. The examples that follow divide this process into the following tasks:</p>

<ul>
<li>Begin tracking newly created R objects, sync with the outputplan (defined below) and start a log file</li>
<li>Address mathematical symbols needed for headers/footers/titles</li>
<li>Create the graphic/table

<ul>
<li>Load or create data set(s) for graphic/table components</li>
<li>Pre-Process data set(s)</li>
<li>Create graphic object(s)</li>
<li>Post process graphic object(s) </li>
</ul></li>
<li>A call build.page to assemble object(s) on the page</li>
<li>A call annotate.page to add headers/footers/titles</li>
<li>Remove R objects created and close the log file</li>
</ul>

<h2>The outputplan and the refresh.outputplan function</h2>

<p>In practice, the outputplan is read from a .csv file that may be centrally located (to facilitate editing by team members). One can populate the outputplan in excel to facilitate syncing with related files (e.g., the qcplan).  </p>

<p>The outputplan holds metadata for each figure.  One row is allocated to each figure.  The outputplan can have superfluous columns. As a rule, entries in the outputfile are intended to be unique. This allows the driver files, the files stored in the directory and whose names are in stored also stored in the rcode column of the outputplan, to uniquely identify the row associated with the figure being produced allowing the annotate.page function to populate the figure&#39;s headers and footers.  Superfluous columns are ok (and may prove helpful if you are using the outputplan to help populate driver files). See annotate.page code for the minimum subset of columns required in addition to outputfile and rocde columns. </p>

<p>The figuRes2 package has a dummy outputplan stored as a data set.</p>

<pre><code class="r">require(figuRes2); require(stringr)
data(outputplan)
# Run the next line to see first 6 rows
# head(outputplan)
</code></pre>

<p>The figuRes2::refresh.outputplan function is used to process a data.frame sharing a subset of these column names. In addition to handling some pre-processing tasks when the outputplan is read from a .csv file, this function:</p>

<ul>
<li>counts the number of lines to allocate for titles: nTitleLines</li>
<li>counts the number of lines to allocate for footnotes: nFootLines</li>
</ul>

<p>These can be leveraged to dynamically adapt the graph region to accommodate title and footer requirements.</p>

<pre><code class="r"># loadplan=F presumes outputplan exists in the Global environment
refresh.outputplan(loadplan=F) 
# Note the additional columns created these will get passed to annotate.page
names(outputplan)
</code></pre>

<pre><code>##  [1] &quot;Study&quot;        &quot;Section&quot;      &quot;Number&quot;       &quot;FigureNumber&quot; &quot;TableID&quot;     
##  [6] &quot;HarpTitle&quot;    &quot;PlotStyle&quot;    &quot;ulh1&quot;         &quot;ulh2&quot;         &quot;ulh3&quot;        
## [11] &quot;urh1&quot;         &quot;urh2&quot;         &quot;urh3&quot;         &quot;fnote1&quot;       &quot;fnote2&quot;      
## [16] &quot;fnote3&quot;       &quot;fnote4&quot;       &quot;outputfile&quot;   &quot;rcode&quot;        &quot;csv&quot;         
## [21] &quot;FigureTitle&quot;  &quot;Author&quot;       &quot;Response&quot;     &quot;RunThis&quot;      &quot;FigureTitle4&quot;
## [26] &quot;FigureTitle3&quot; &quot;FigureTitle2&quot; &quot;FigureTitle1&quot; &quot;nTitleLines&quot;  &quot;nFootLines&quot;
</code></pre>

<p>This function can also read an outputplan stored in an external .csv file, preprocess it, and store the resultant data.frame, called outputplan, in the Global Environment. Regarding the uniqueness of names found in the outputfile column mentioned above, one can subset the outputplan at this point in a way that assures this at this point.  E.g., if the external outputplan holds metadata for multiple projects and these projects are intended to produce files with common names, one could subset the outputplan to isolate a single project, thus ensuring that the outputplan used by R meets the constraint.   </p>

<h2>The run.specific function</h2>

<p>This function takes a driver name and optionally outputs it to the screen or any number of file formats. This function presumes the driver is located in the code directory mentioned above and that files are sent to the output directory.  </p>

<p>This and all_in_one are wrapper functions for grDevices::pdf and related functions.</p>

<h2>all_in_one</h2>

<p>This function loops through an outputplan producing figures whenever a row entry for a stated column takes the value &ldquo;Y&rdquo;. The driver file name used for sourcing is obtained from the rcode column of the outputplan.</p>

<h1>Large scale production workflow</h1>

<p>The following outlines the gestalt approach successfully employed in clinical trial reporting. </p>

<h2>Set up local directory structure</h2>

<p>Warning the following code will create directories on your computer for the purpose of demonstration!! Ensure your working directory is pointing to a folder that you can use for experimenting. </p>

<pre><code class="r"># Replace the paths for your machine.

default.settings(
        my.path = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/&quot;,
        od = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/output/&quot;,
        dd = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/dddata/&quot;,
        cd = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/code/&quot;,
        logd = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/log/&quot;)

# This code creates directory at the locations specified.
dir.create(file.path(cd), showWarnings = FALSE)
dir.create(file.path(dd), showWarnings = FALSE)
dir.create(file.path(od), showWarnings = FALSE)
dir.create(file.path(logd), showWarnings = FALSE)
</code></pre>

<h2>Populating the data folder with mock .csv files</h2>

<p>The following code brings data sets stored in the figuRes2 packages into Global Environment.</p>

<pre><code class="r">data(outputplan)
data(benrisk2.data)
data(summary.lineplot.data)
data(boxplot.driver)
data(demog.data)
data(forest.data)
data(cdf.data)
data(km.data)
data(raw.lineplot.data)
data(lineplot.data)
</code></pre>

<p>The following saves these datasets as .csv files in the dddata directory. In practice, files are transfered from elsewhere into your dddata folder.  </p>

<pre><code class="r">write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;outputplan.csv&quot;), outputplan)
write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;benrisk2.data.csv&quot;), benrisk2.data)
write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;summary.lineplot.data.csv&quot;), summary.lineplot.data)
write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;g_bslchar.csv&quot;), demog.data)
write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;forest.data.csv&quot;), forest.data)
write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;cdf.data.csv&quot;), cdf.data)
write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;km.data.csv&quot;), km.data)
write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;raw.lineplot.data.csv&quot;), raw.lineplot.data)
write.csv(file=file.path(my.path, &quot;dddata&quot;, &quot;lineplot_example.csv&quot;), raw.lineplot.data)
</code></pre>

<h2>Populating the code directory with driver files</h2>

<h3>Mimicking the creation of authoring individual driver files</h3>

<p>Let&#39;s populate with some other prefabricated driver files stored in the figuRes2 package as datasets. These are first loaded into R&#39;s Global Environment.</p>

<pre><code class="r">data(continuous_by_visit_and_treatment) # driver1
data(category_by_visit) # driver2
data(scatter_smooth) # driver 3
data(scatter_smooth_facet) # driver 4
data(scatterplot_with_smoother) # driver5
data(cdf_weight) # driver8
data(priordens) # driver9
</code></pre>

<p>These are now written as text files to the code folder using a .r extension. This process would mimic the creation of nine separate driver files.</p>

<pre><code class="r">writeLines(driver1, con=paste0(cd,&quot;continuous_by_visit_and_treatment.r&quot;))
writeLines(driver2, con=paste0(cd,&quot;category_by_visit.r&quot;))
writeLines(driver3, con=paste0(cd,&quot;scatter_smooth.r&quot;))
writeLines(driver4, con=paste0(cd,&quot;scatter_smooth_facet.r&quot;))
writeLines(driver5, con=paste0(cd,&quot;scatterplot_with_smoother.r&quot;))
writeLines(driver8, con=paste0(cd,&quot;cdf_weight.r&quot;))
writeLines(driver9, con=paste0(cd,&quot;priordens.r&quot;))
</code></pre>

<h3>Getting R to build drivers with pattern replacement</h3>

<p>This approach might be considered if you need to create 15+ driver files that differ only in a few locations. The following code brings a skeletonized driver for building box plots into the code directory.</p>

<pre><code class="r"># Write boxplot.driver file to code directory
writeLines(boxplot.driver, con=file.path(cd, &quot;boxplot.driver.txt&quot;))
</code></pre>

<p>By making use of columns included in the outputplan and the skeletonized driver, we can have R populate the driver files and store these the code directory. The idea here is to search through the skeletonized driver for a predefined set of text patterns, replace those patterns with values taken from columns of the outputplan and save the result with a predefined filename.  </p>

<p>WARNING: in practice it would be a good idea to have these populated in a staging directory to avoid inadvertently overwriting files!</p>

<pre><code class="r">outputplan.bp &lt;- subset(outputplan, PlotStyle == &quot;Boxplot&quot; &amp; Response != &quot;&quot;)

 for(i in 1:nrow(outputplan.bp )){
   tx  &lt;- boxplot.driver
   tx  &lt;- gsub(pattern = &quot;@ProgramName&quot;, replace = paste(outputplan.bp$Study[i], 
                    outputplan.bp$ULHead1[i]), x = tx)
   tx  &lt;- gsub(pattern = &quot;@DataFileName&quot;, replace = outputplan.bp$csv[i], x = tx)
   tx  &lt;- gsub(pattern = &quot;@OutputName&quot;, replace = outputplan.bp$outputfile[i], x = tx)
   tx  &lt;- gsub(pattern = &quot;@RESPONSE&quot;, replace = outputplan.bp$Response[i], x = tx)
   tx  &lt;- gsub(pattern = &quot;@ProtocolID&quot;, replace = outputplan.bp$ulh1[i], x = tx)
   tx  &lt;- gsub(pattern = &quot;@PlotStyle&quot;, replace = outputplan.bp$PlotStyle[i], x = tx)
   tx  &lt;- gsub(pattern = &quot;@FigureTitle&quot;, replace = outputplan.bp$HarpTitle[i], x = tx)
   tx  &lt;- gsub(pattern = &quot;@TableRef&quot;, replace = outputplan.bp$TableID[i], x = tx)
   tx  &lt;- gsub(pattern = &quot;@Author&quot;, replace = outputplan.bp$Author[i], x = tx)
   tx  &lt;- gsub(pattern = &quot;@Date&quot;, replace = Sys.Date(), x = tx)
   writeLines(tx, con=paste0(cd,outputplan.bp$rcode[i]))
 }
</code></pre>

<h2>Simulating a session</h2>

<p>At this point, all of the components are in place to create figuRes. First, let&#39;s ensure items are cleared from the Global Environment to mimic a fresh session start.  </p>

<pre><code class="r">remove(list=ls())
</code></pre>

<pre><code class="r"># require(figuRes2)
# ./workflowdemo should still be the working directory.
#setwd(file.path(getwd(), &quot;workflowdemo&quot;))
default.settings(
        my.path = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/&quot;,
        od = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/output/&quot;,
        dd = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/dddata/&quot;,
        cd = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/code/&quot;,
        logd = &quot;C:/Users/eri7441/OneDrive - Takeda/Documents/R packages/figuRes2 - testing/log/&quot;)
</code></pre>

<h3>Importing the outputplan</h3>

<p>In practice, the outputplan would be read in from .csv file.</p>

<pre><code class="r">data(outputplan)
head(outputplan)
refresh.outputplan(loadplan=F)
</code></pre>

<h3>Running individual .pdf files</h3>

<p>Apply run.specific:</p>

<pre><code class="r">run.specific(as.character(outputplan$rcode[1]), toPDF=T)
run.specific(as.character(outputplan$rcode[2]), toPDF=T)
run.specific(as.character(outputplan$rcode[3]), toPDF=T)
run.specific(as.character(outputplan$rcode[4]), toPDF=T)
run.specific(as.character(outputplan$rcode[5]), toPDF=T)
run.specific(as.character(outputplan$rcode[6]), toPDF=T)
run.specific(as.character(outputplan$rcode[7]), toPDF=T)
run.specific(as.character(outputplan$rcode[8]), toPDF=T)
run.specific(as.character(outputplan$rcode[9]), toPDF=T)
run.specific(as.character(outputplan$rcode[12]), toPDF=T)
run.specific(as.character(outputplan$rcode[13]), toPDF=T)
run.specific(as.character(outputplan$rcode[14]), toPDF=T)
# In practice it may be easier to work with the filename, e.g.,
</code></pre>

<p>At this point, the output directory should have 12 pdf files. (With 16 rows in our outputplan we have some rows skipped.)</p>

<h3>Populating a single .pdf file with multiple figuRes2</h3>

<p>Finally, here is a call to produce a single pdf with all figuRes2.</p>

<pre><code class="r">all_in_one(UseSubset = &quot;RunThis&quot;, filename= &quot;allinone.PDF&quot; , reportNR=FALSE)
</code></pre>

</body>

</html>
